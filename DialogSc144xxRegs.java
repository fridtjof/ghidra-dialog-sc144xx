//Set up registers and a basic memory map for SC144xx (currently only SC14481)
//@author fridtjof
//@category Project
//@keybinding 
//@menupath 
//@toolbar 

import com.google.gson.*;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.data.*;

import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;

import java.io.FileReader;
import java.util.*;

import static ghidra.app.util.MemoryBlockUtils.createUninitializedBlock;
import static ghidra.program.model.data.DataUtilities.createData;

public class DialogSc144xxRegs extends GhidraScript {
    public static final class MemRegionDef {
        String start_addr;
        String end_addr;
        String permissions;
    }

    public static final class RegisterDef {
        String zone_name;
        String addr;
        int size;
        int base;
        String bit_range; // optional, should only really appear on fields?
        Map<String, Object> fields; // optional
    }

    public static final class ChipDef {
        Map<String, MemRegionDef> mmap;
        Map<String, RegisterDef> sfr;
        Map<String, List<String>> groups;
    }

    public void run() throws Exception {
        var log = new MessageLog();
        var dir = this.sourceFile.getParentFile();

        //var files = dir.listFiles(file -> !file.getName().endsWith(".java"));

        var jsonFile = askFile("Please select json generated by dump.py", "Choose");
        //var choices = new ArrayList<String>();
        //choices.add("SC14441");
        //choices.add("SC14443");
        //choices.add("SC14450");
        //choices.add("SC14481");
        //askChoice("", "", choices, null);

        Gson gson = new Gson();
        var data = gson.fromJson(new FileReader(jsonFile), ChipDef.class);

        addHardwareBlocks(this.currentProgram, log, data.mmap);
        populateHardwareBlocks(this.currentProgram, data.sfr);
    }

    static final class DataTypes {
        public static final ByteDataType u8 = ByteDataType.dataType;
        public static final WordDataType u16 = WordDataType.dataType;
        public static final DWordDataType u32 = DWordDataType.dataType;
        public static final CharDataType ch = CharDataType.dataType;

        //static Array array(DataType d, int size) {
        //    return new ArrayDataType(d, size, -1);
        //}
    }

    public static void addHardwareBlocks(Program program, MessageLog log, Map<String, MemRegionDef> mmap) {
        var as = program.getAddressFactory().getDefaultAddressSpace();

        var regionName = "SFR";

        var sfr_region = mmap.get(regionName);

        int startAddress = Integer.parseInt(sfr_region.start_addr.replace("0x", ""), 16);
        int endAddress = Integer.parseInt(sfr_region.end_addr.replace("0x", ""), 16) + 1;
        var perms = sfr_region.permissions;

        //var startAddress = 0xFF_0000;
        //var endAddress = 0xFF_FBFF + 1;
        var comment = "Special Function Registers";

        var read = perms.contains("R");
        var write = perms.contains("W");
        var execute = false;
        var io = createUninitializedBlock(program, false, regionName, as.getAddress(startAddress), endAddress - startAddress, comment, "", read, write, execute, log);
        if (io != null) {
            // todo: does not apply to all regs but no information.
            //  either use heuristics (based on name) or just set everything uninitialized to volatile
            io.setVolatile(true);
        }
    }

    record Reg(String name, long address, DataType type) {}

    public void populateHardwareBlocks(Program program, Map<String, RegisterDef> regs) {
        var as = program.getAddressFactory().getDefaultAddressSpace();

        regs.forEach((name, def) -> {
            try {
                addSfr(program, name, def);
            } catch (Exception e) {
                this.printerr(e.getMessage());
            }
        });
    }

    private void addSfr(Program program, String name, RegisterDef r) throws Exception {
        var as = program.getAddressFactory().getDefaultAddressSpace();

        var addr = as.getAddress(Long.parseLong(r.addr.replace("0x", ""), 16));
        var type = switch (r.size) {
            case 1 -> DataTypes.u8;
            case 2 -> DataTypes.u16;
            case 4 -> DataTypes.u32;
            default -> throw new Exception("wow new datatype");
        };

        DataUtilities.createData(program, addr, type, -1, false, DataUtilities.ClearDataMode.CLEAR_ALL_CONFLICT_DATA);
        program.getSymbolTable().createLabel(addr, name, SourceType.IMPORTED).setPinned(true);

        // TODO add bitfield maybe, but ghidra's decompiler doesn't really do anything with them :(
    }
}
